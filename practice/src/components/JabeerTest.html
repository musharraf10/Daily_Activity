<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Happy Birthday - Cinematic Journey</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;700&family=Inter:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: "Inter", sans-serif;
        overflow: hidden;
        background: #000;
        color: white;
        position: relative;
        touch-action: manipulation;
      }

      /* Cinematic Background */
      .cinematic-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 80%,
            rgba(0, 255, 255, 0.15) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 20%,
            rgba(255, 0, 255, 0.15) 0%,
            transparent 50%
          ),
          linear-gradient(135deg, #000428 0%, #004e92 100%);
        z-index: -2;
      }

      .film-grain {
        position: fixed;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(255, 255, 255, 0.03) 2px,
          rgba(255, 255, 255, 0.03) 4px
        );
        animation: filmGrain 0.2s linear infinite;
        pointer-events: none;
        z-index: 10;
        opacity: 0.5;
      }

      @keyframes filmGrain {
        0% {
          transform: translate(0, 0);
        }
        10% {
          transform: translate(-1px, -1px);
        }
        20% {
          transform: translate(1px, 0);
        }
        30% {
          transform: translate(-1px, 1px);
        }
        40% {
          transform: translate(0, -1px);
        }
        50% {
          transform: translate(1px, 1px);
        }
        60% {
          transform: translate(-1px, 0);
        }
        70% {
          transform: translate(0, 1px);
        }
        80% {
          transform: translate(1px, -1px);
        }
        90% {
          transform: translate(-1px, -1px);
        }
        100% {
          transform: translate(0, 0);
        }
      }

      /* Terminal Boot Overlay - Mobile First */
      #terminal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        background: #000;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 20px;
        transition: all 1.2s cubic-bezier(0.19, 1, 0.22, 1);
      }

      #terminal-overlay.hidden {
        opacity: 0;
        transform: scale(0.8);
        pointer-events: none;
      }

      .terminal-content {
        font-family: "JetBrains Mono", monospace;
        font-size: clamp(10px, 3.5vw, 14px);
        color: #00ff00;
        width: 100%;
        max-width: 90vw;
        text-align: left;
      }

      .terminal-line {
        margin-bottom: clamp(4px, 2vw, 8px);
        opacity: 0;
        animation: terminalLineIn 0.6s ease-out forwards;
        text-shadow: 0 0 10px #00ff0080;
      }

      @keyframes terminalLineIn {
        0% {
          opacity: 0;
          transform: translateX(-20px);
        }
        100% {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .progress-container {
        width: 100%;
        margin: clamp(15px, 5vw, 30px) 0;
        padding: 0 10px;
      }

      .progress-bar {
        width: 100%;
        height: 6px;
        background: #333;
        border-radius: 3px;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff00, #00ffff, #ff00ff);
        width: 0;
        transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
      }

      .boot-complete {
        color: #00ffff;
        font-weight: bold;
        text-align: center;
        margin-top: clamp(15px, 5vw, 25px);
        font-size: clamp(14px, 4vw, 20px);
        font-family: "Orbitron", monospace;
        text-shadow: 0 0 20px #00ffff;
        animation: pulse 1s ease-in-out infinite alternate;
      }

      @keyframes pulse {
        0% {
          text-shadow: 0 0 20px #00ffff;
        }
        100% {
          text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff;
        }
      }

      /* Main 3D Scene Container */
      #scene-container {
        position: relative;
        width: 100%;
        height: 100vh;
        overflow: hidden;
      }

      canvas {
        display: block;
        touch-action: none;
      }

      /* Mobile-First UI Overlays */
      .ui-overlay {
        position: fixed;
        pointer-events: none;
        z-index: 100;
      }

      /* Cinematic HUD */
      .hud-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 150;
      }

      .hud-corners {
        position: absolute;
        width: clamp(30px, 8vw, 60px);
        height: clamp(30px, 8vw, 60px);
        border: 2px solid #00ffff;
        opacity: 0.6;
      }

      .hud-corners.top-left {
        top: 20px;
        left: 20px;
        border-right: none;
        border-bottom: none;
      }

      .hud-corners.top-right {
        top: 20px;
        right: 20px;
        border-left: none;
        border-bottom: none;
      }

      .hud-corners.bottom-left {
        bottom: 20px;
        left: 20px;
        border-right: none;
        border-top: none;
      }

      .hud-corners.bottom-right {
        bottom: 20px;
        right: 20px;
        border-left: none;
        border-top: none;
      }

      /* Mobile Instructions */
      .mobile-instructions {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(20px);
        padding: 15px 25px;
        border-radius: 25px;
        border: 1px solid rgba(0, 255, 255, 0.3);
        text-align: center;
        font-size: clamp(12px, 3.5vw, 14px);
        opacity: 1;
        transition: all 1s ease-out;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .mobile-instructions.fade-out {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }

      .gesture-hint {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-top: 8px;
        font-size: clamp(10px, 3vw, 12px);
        color: #00ffff;
      }

      /* Floating Control Panel */
      .control-panel {
        position: fixed;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        z-index: 200;
      }

      .control-btn {
        width: clamp(45px, 12vw, 55px);
        height: clamp(45px, 12vw, 55px);
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(20px);
        border: 2px solid #00ffff;
        color: #00ffff;
        cursor: pointer;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(18px, 5vw, 22px);
        transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }

      .control-btn:active {
        transform: scale(0.9);
        box-shadow: 0 5px 15px rgba(0, 255, 255, 0.5);
      }

      .control-btn:hover {
        background: rgba(0, 255, 255, 0.2);
        transform: scale(1.1);
        box-shadow: 0 15px 35px rgba(0, 255, 255, 0.4);
      }

      /* Immersive Popup Cards */
      .popup-card {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%) scale(0) rotateY(90deg);
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(25px);
        border: 2px solid #00ffff;
        border-radius: 20px;
        padding: clamp(20px, 6vw, 40px);
        max-width: 90vw;
        width: clamp(280px, 85vw, 400px);
        text-align: center;
        z-index: 300;
        transition: all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.8),
          0 0 80px rgba(0, 255, 255, 0.3);
      }

      .popup-card.show {
        transform: translate(-50%, -50%) scale(1) rotateY(0deg);
      }

      .popup-card h2 {
        color: #00ffff;
        margin-bottom: 20px;
        font-size: clamp(20px, 6vw, 28px);
        font-family: "Orbitron", sans-serif;
        font-weight: 900;
        text-shadow: 0 0 20px #00ffff;
      }

      .popup-card p {
        line-height: 1.8;
        font-size: clamp(14px, 4vw, 18px);
        color: rgba(255, 255, 255, 0.9);
      }

      /* Cinematic Checkpoint Display */
      .checkpoint-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        z-index: 250;
        transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        max-width: 90vw;
        max-height: 80vh;
      }

      .checkpoint-container.show {
        transform: translate(-50%, -50%) scale(1);
      }

      .checkpoint-image {
        width: clamp(250px, 80vw, 350px);
        height: auto;
        max-height: 50vh;
        object-fit: cover;
        border-radius: 15px;
        border: 3px solid #00ffff;
        box-shadow: 0 0 50px rgba(0, 255, 255, 0.6),
          0 25px 50px rgba(0, 0, 0, 0.8);
        filter: saturate(1.2) contrast(1.1);
      }

      .checkpoint-quote {
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(20px);
        padding: 15px 25px;
        border-radius: 25px;
        border: 1px solid rgba(0, 255, 255, 0.5);
        margin-top: 15px;
        text-align: center;
        font-size: clamp(12px, 3.5vw, 16px);
        color: #00ffff;
        font-style: italic;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      }

      /* Journey Progress Indicator */
      .journey-progress {
        position: fixed;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        width: clamp(200px, 60vw, 300px);
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        z-index: 150;
      }

      .journey-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff00, #00ffff, #ff00ff);
        width: 0%;
        border-radius: 2px;
        transition: width 0.3s ease;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      }

      /* Particle Effects Overlay */
      .particles-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
        background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%2300ffff' fill-opacity='0.1'%3E%3Ccircle cx='30' cy='30' r='1'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        animation: particleFloat 20s linear infinite;
      }

      @keyframes particleFloat {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        100% {
          transform: translate(-60px, -60px) rotate(360deg);
        }
      }

      /* Responsive Typography */
      @media (max-width: 480px) {
        .terminal-content {
          font-size: 11px;
        }

        .control-btn {
          width: 50px;
          height: 50px;
          font-size: 20px;
        }

        .popup-card {
          padding: 25px;
          border-radius: 15px;
        }
      }

      /* High-end device enhancements */
      @media (min-width: 1024px) {
        .film-grain {
          opacity: 0.3;
        }

        .checkpoint-image {
          max-width: 400px;
          max-height: 60vh;
        }

        .popup-card {
          max-width: 450px;
        }
      }

      /* Landscape orientation adjustments */
      @media (orientation: landscape) and (max-height: 600px) {
        .checkpoint-container {
          max-height: 70vh;
        }

        .checkpoint-image {
          max-height: 40vh;
        }

        .mobile-instructions {
          bottom: 10px;
          padding: 10px 20px;
        }
      }

      /* Reduce Motion Support */
      @media (prefers-reduced-motion: reduce) {
        .film-grain,
        .particles-overlay {
          animation: none;
        }

        .terminal-line,
        .popup-card,
        .checkpoint-container {
          transition: opacity 0.3s ease;
        }

        .control-btn {
          transition: transform 0.2s ease;
        }
      }

      /* Loading States */
      .loading-spinner {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        border: 3px solid rgba(0, 255, 255, 0.3);
        border-top: 3px solid #00ffff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        z-index: 400;
        display: none;
      }

      @keyframes spin {
        0% {
          transform: translate(-50%, -50%) rotate(0deg);
        }
        100% {
          transform: translate(-50%, -50%) rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <!-- Cinematic Background -->
    <div class="cinematic-bg"></div>
    <div class="film-grain"></div>
    <div class="particles-overlay"></div>

    <!-- Terminal Boot Overlay -->
    <div id="terminal-overlay">
      <div class="terminal-content">
        <div id="terminal-lines"></div>
        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
        </div>
        <div class="boot-complete" id="boot-complete" style="display: none">
          🎉 BIRTHDAY SYSTEM ONLINE 🎉<br />
          <span style="font-size: 0.8em">INITIALIZING MEMORY JOURNEY...</span>
        </div>
      </div>
    </div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loading-spinner"></div>

    <!-- Main Scene Container -->
    <div id="scene-container"></div>

    <!-- Cinematic HUD -->
    <div class="hud-container">
      <div class="hud-corners top-left"></div>
      <div class="hud-corners top-right"></div>
      <div class="hud-corners bottom-left"></div>
      <div class="hud-corners bottom-right"></div>
    </div>

    <!-- Journey Progress -->
    <div class="journey-progress">
      <div class="journey-fill" id="journey-fill"></div>
    </div>

    <!-- Mobile Instructions -->
    <div class="mobile-instructions" id="mobile-instructions">
      <div>🎂 Swipe to explore your journey</div>
      <div class="gesture-hint">
        <span>👆 Wishes</span>
        <span>•</span>
        <span>👇 Quotes</span>
      </div>
    </div>

    <!-- Floating Control Panel -->
    <div class="control-panel">
      <button class="control-btn" id="reboot-btn" title="Restart Journey">
        ⟲
      </button>
      <button class="control-btn" id="fullscreen-btn" title="Fullscreen">
        ⛶
      </button>
      <button class="control-btn" id="music-btn" title="Toggle Audio">♪</button>
    </div>

    <!-- Immersive Popup Cards -->
    <div class="popup-card" id="wish-card">
      <h2>🎉 HAPPY BIRTHDAY! 🎉</h2>
      <p>
        On this special day, may every moment sparkle with joy and every dream
        take flight. You are extraordinary, and this new year of your life is
        going to be absolutely amazing. Here's to adventures untold and memories
        yet to be made!
      </p>
    </div>

    <div class="popup-card" id="quote-card">
      <h2>✨ BIRTHDAY WISDOM</h2>
      <p id="random-quote">
        "Another year older, another level of awesome unlocked!"
      </p>
    </div>

    <!-- Cinematic Checkpoint Display -->
    <div class="checkpoint-container" id="checkpoint-container">
      <img class="checkpoint-image" id="checkpoint-image" src="" alt="Memory" />
      <div class="checkpoint-quote" id="checkpoint-quote"></div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script>
      // Enhanced Configuration for Cinematic Experience
      const CONFIG = {
        // Cinematic boot sequence
        bootLines: [
          "[INIT] 🎬 CINEMATIC_SYSTEM v3.0.1 - BIRTHDAY_EDITION",
          "[SCAN] 📱 mobile-optimization ... ENABLED",
          "[PROC] 🎨 loading-visual-effects...",
          "[AUTH] 🎂 verifying-birthday-person... AUTHENTICATED",
          "[LOAD] ✨ memories-database ... 1,247 files found",
          "[SPAWN] 🎉 celebration-service PID=2024",
          "[MOUNT] 💕 love-filesystem ... MOUNTED",
          "[INIT] 🌟 particle-system ... ACTIVE",
          "[BOOT] 🚀 launching-cinematic-journey...",
        ],

        // High-quality placeholder images
        images: [
          "https://picsum.photos/600/400?random=1&birthday",
          "https://picsum.photos/600/400?random=2&celebration",
          "https://picsum.photos/600/400?random=3&memories",
          "https://picsum.photos/600/400?random=4&friends",
          "https://picsum.photos/600/400?random=5&adventure",
          "https://picsum.photos/600/400?random=6&happiness",
          "https://picsum.photos/600/400?random=7&dreams",
          "https://picsum.photos/600/400?random=8&journey",
          "https://picsum.photos/600/400?random=9&love",
          "https://picsum.photos/600/400?random=10&life",
        ],

        // Cinematic birthday quotes
        quotes: [
          "🎮 Achievement Unlocked: +1 Year of Epic Adventures!",
          "🌟 Plot twist: This year is going to be your best chapter yet!",
          "🎬 And... ACTION! Your starring role in an amazing year begins now!",
          "✨ Level up complete: Wisdom +100, Happiness +∞",
          "🚀 Mission brief: Make this year absolutely extraordinary!",
          "🎭 Today's forecast: 100% chance of birthday magic!",
          "🎪 Step right up to another year of incredible possibilities!",
          "🌈 Director's cut: Your life story keeps getting better!",
          "🎨 Masterpiece in progress: Another year of beautiful moments!",
          "🎵 Hit song: 'Another Year of Being Absolutely Amazing'!",
        ],

        // Visual settings
        visual: {
          pathComplexity: 25,
          routeRadius: 18,
          cameraHeight: 4,
          starCount: 2000,
          particleCount: 500,
        },
      };

      // Global variables
      let scene,
        camera,
        renderer,
        routePath,
        checkpoints = [];
      let pathPosition = 0,
        targetPosition = 0;
      let isDragging = false,
        lastTouchY = 0,
        velocity = 0;
      let currentQuoteIndex = 0,
        quotesShuffled = [...CONFIG.quotes];
      let isInitialized = false;

      // Enhanced mobile touch handling
      let touchStartTime = 0;
      let touchStartY = 0;
      let touchVelocity = 0;
      let isVerticalGesture = false;

      // Terminal boot animation with cinematic effects
      function startBootSequence() {
        const terminalLines = document.getElementById("terminal-lines");
        const progressFill = document.getElementById("progress-fill");
        const bootComplete = document.getElementById("boot-complete");

        let lineIndex = 0;

        function addLine() {
          if (lineIndex < CONFIG.bootLines.length) {
            const line = document.createElement("div");
            line.className = "terminal-line";
            line.textContent = CONFIG.bootLines[lineIndex];
            line.style.animationDelay = `${lineIndex * 0.1}s`;
            terminalLines.appendChild(line);

            // Enhanced progress with glow effect
            const progress = ((lineIndex + 1) / CONFIG.bootLines.length) * 100;
            progressFill.style.width = progress + "%";

            // Add haptic feedback on mobile
            if (navigator.vibrate && lineIndex % 2 === 0) {
              navigator.vibrate(50);
            }

            lineIndex++;
            setTimeout(addLine, 700 + Math.random() * 300);
          } else {
            setTimeout(() => {
              bootComplete.style.display = "block";
              setTimeout(() => {
                document
                  .getElementById("terminal-overlay")
                  .classList.add("hidden");
                setTimeout(() => {
                  document.getElementById("terminal-overlay").style.display =
                    "none";
                  initializeScene();
                }, 1200);
              }, 2000);
            }, 800);
          }
        }

        addLine();
      }

      // Shuffle utility with animation
      function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      // Enhanced scene initialization
      function initializeScene() {
        showLoadingSpinner();

        // Scene setup with enhanced settings
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document
          .getElementById("scene-container")
          .appendChild(renderer.domElement);

        // Enhanced lighting system
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x00ffff, 1.5, 100);
        pointLight1.position.set(0, 20, 0);
        pointLight1.castShadow = true;
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 0.8, 50);
        pointLight2.position.set(15, 10, 15);
        scene.add(pointLight2);

        // Create enhanced route path
        const pathPoints = [];
        const numPoints = CONFIG.visual.pathComplexity;
        const radius = CONFIG.visual.routeRadius;

        for (let i = 0; i < numPoints; i++) {
          const angle = (i / numPoints) * Math.PI * 2;
          const x = Math.cos(angle) * radius + Math.sin(angle * 3) * 4;
          const z = Math.sin(angle) * radius + Math.cos(angle * 2) * 5;
          const y = Math.sin(angle * 4) * 3 + Math.cos(angle * 6) * 1.5;
          pathPoints.push(new THREE.Vector3(x, y, z));
        }

        routePath = new THREE.CatmullRomCurve3(pathPoints, true);

        // Enhanced glowing route
        createGlowingRoute();
        createCheckpoints();
        createEnhancedStarField();
        createFloatingParticles();

        // Setup enhanced controls
        setupEnhancedControls();

        // Position camera
        updateCameraPosition();

        hideLoadingSpinner();
        startAnimationLoop();

        // Fade instructions after 6 seconds
        setTimeout(() => {
          document
            .getElementById("mobile-instructions")
            .classList.add("fade-out");
        }, 6000);

        isInitialized = true;
      }

      // Create glowing route with multiple layers
      function createGlowingRoute() {
        // Main route tube
        const tubeGeometry = new THREE.TubeGeometry(
          routePath,
          300,
          0.15,
          12,
          true
        );
        const tubeMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.9,
        });
        const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
        scene.add(tube);

        // Outer glow
        const glowGeometry = new THREE.TubeGeometry(
          routePath,
          300,
          0.3,
          12,
          true
        );
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glow);

        // Animated inner core
        const coreGeometry = new THREE.TubeGeometry(
          routePath,
          300,
          0.05,
          8,
          true
        );
        const coreMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 1,
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);

        // Animate the core
        gsap.to(coreMaterial, {
          opacity: 0.5,
          duration: 1,
          repeat: -1,
          yoyo: true,
          ease: "power2.inOut",
        });
      }

      // Enhanced checkpoint creation
      function createCheckpoints() {
        CONFIG.images.forEach((imageUrl, index) => {
          const t = index / CONFIG.images.length;
          const position = routePath.getPointAt(t);

          // Main checkpoint sphere
          const geometry = new THREE.SphereGeometry(0.4, 20, 20);
          const material = new THREE.MeshPhongMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.8,
            emissive: 0x003300,
          });
          const checkpoint = new THREE.Mesh(geometry, material);
          checkpoint.position.copy(position);
          checkpoint.position.y += 3;

          // Multiple glow layers for depth
          const glowSizes = [0.6, 0.8, 1.2];
          const glowOpacities = [0.4, 0.25, 0.15];
          const glows = [];

          glowSizes.forEach((size, i) => {
            const glowGeometry = new THREE.SphereGeometry(size, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: 0x00ff00,
              transparent: true,
              opacity: glowOpacities[i],
            });
            const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            glowSphere.position.copy(checkpoint.position);
            glows.push(glowSphere);
            scene.add(glowSphere);
          });

          scene.add(checkpoint);

          checkpoints.push({
            mesh: checkpoint,
            glows: glows,
            position: t,
            imageUrl: imageUrl,
            shown: false,
          });

          // Enhanced animations
          gsap.to(checkpoint.rotation, {
            y: Math.PI * 2,
            duration: 3 + Math.random() * 2,
            repeat: -1,
            ease: "none",
          });

          glows.forEach((glow, i) => {
            gsap.to(glow.scale, {
              x: 1.3 + i * 0.2,
              y: 1.3 + i * 0.2,
              z: 1.3 + i * 0.2,
              duration: 1.5 + i * 0.5,
              repeat: -1,
              yoyo: true,
              ease: "power2.inOut",
            });
          });
        });
      }

      // Enhanced star field
      function createEnhancedStarField() {
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 2,
          transparent: true,
          opacity: 0.8,
          sizeAttenuation: true,
        });

        const starsVertices = [];
        const starsColors = [];

        for (let i = 0; i < CONFIG.visual.starCount; i++) {
          const x = (Math.random() - 0.5) * 300;
          const y = (Math.random() - 0.5) * 300;
          const z = (Math.random() - 0.5) * 300;
          starsVertices.push(x, y, z);

          // Random star colors
          const colorChoice = Math.random();
          if (colorChoice < 0.7) {
            starsColors.push(1, 1, 1); // White
          } else if (colorChoice < 0.85) {
            starsColors.push(0, 1, 1); // Cyan
          } else {
            starsColors.push(1, 0, 1); // Magenta
          }
        }

        starsGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(starsVertices, 3)
        );
        starsGeometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(starsColors, 3)
        );

        starsMaterial.vertexColors = true;

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Animate stars
        gsap.to(stars.rotation, {
          x: Math.PI * 2,
          duration: 200,
          repeat: -1,
          ease: "none",
        });
      }

      // Create floating particles
      function createFloatingParticles() {
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesMaterial = new THREE.PointsMaterial({
          color: 0x00ffff,
          size: 3,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending,
        });

        const particlesVertices = [];

        for (let i = 0; i < CONFIG.visual.particleCount; i++) {
          const x = (Math.random() - 0.5) * 100;
          const y = (Math.random() - 0.5) * 100;
          const z = (Math.random() - 0.5) * 100;
          particlesVertices.push(x, y, z);
        }

        particlesGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(particlesVertices, 3)
        );
        const particles = new THREE.Points(
          particlesGeometry,
          particlesMaterial
        );
        scene.add(particles);

        // Animate particles
        gsap.to(particles.rotation, {
          y: Math.PI * 2,
          duration: 100,
          repeat: -1,
          ease: "none",
        });
      }

      // Enhanced mobile-first controls
      function setupEnhancedControls() {
        const canvas = renderer.domElement;

        // Touch controls with improved gestures
        canvas.addEventListener("touchstart", handleTouchStart, {
          passive: false,
        });
        canvas.addEventListener("touchmove", handleTouchMove, {
          passive: false,
        });
        canvas.addEventListener("touchend", handleTouchEnd, { passive: false });

        // Mouse controls for desktop
        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUp);

        // Wheel control
        canvas.addEventListener("wheel", handleWheel, { passive: false });

        // Keyboard controls
        document.addEventListener("keydown", handleKeyDown);

        // UI button controls
        document
          .getElementById("reboot-btn")
          .addEventListener("click", rebootSystem);
        document
          .getElementById("fullscreen-btn")
          .addEventListener("click", toggleFullscreen);
        document
          .getElementById("music-btn")
          .addEventListener("click", toggleMusic);

        // Window resize
        window.addEventListener("resize", handleResize);
      }

      // Enhanced touch handling
      function handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
          touchStartTime = Date.now();
          touchStartY = e.touches[0].clientY;
          lastTouchY = touchStartY;
          touchVelocity = 0;
          isDragging = true;
          isVerticalGesture = false;

          // Haptic feedback
          if (navigator.vibrate) {
            navigator.vibrate(30);
          }
        }
      }

      function handleTouchMove(e) {
        e.preventDefault();
        if (isDragging && e.touches.length === 1) {
          const currentY = e.touches[0].clientY;
          const deltaY = currentY - lastTouchY;
          const totalDelta = Math.abs(currentY - touchStartY);

          if (totalDelta > 20) {
            isVerticalGesture = true;
          }

          if (isVerticalGesture) {
            touchVelocity = deltaY * 0.002;
            targetPosition += touchVelocity;
            updateJourneyProgress();
          }

          lastTouchY = currentY;
        }
      }

      function handleTouchEnd(e) {
        if (isDragging) {
          const touchDuration = Date.now() - touchStartTime;
          const totalDelta = lastTouchY - touchStartY;

          // Gesture detection
          if (touchDuration < 500 && Math.abs(totalDelta) > 80) {
            if (totalDelta < 0) {
              // Swipe up - show wishes
              showWishCard();
            } else {
              // Swipe down - show quotes
              showQuoteCard();
            }
          }

          // Apply momentum
          if (Math.abs(touchVelocity) > 0.001) {
            gsap.to(this, {
              duration: 1.5,
              ease: "power2.out",
              onUpdate: () => {
                targetPosition += touchVelocity;
                touchVelocity *= 0.95;
                updateJourneyProgress();
              },
            });
          }

          isDragging = false;
          isVerticalGesture = false;
        }
      }

      // Mouse controls
      function handleMouseDown(e) {
        isDragging = true;
        lastTouchY = e.clientY;
        canvas.style.cursor = "grabbing";
      }

      function handleMouseMove(e) {
        if (isDragging) {
          const deltaY = e.clientY - lastTouchY;
          targetPosition += deltaY * 0.001;
          lastTouchY = e.clientY;
          updateJourneyProgress();
        }
      }

      function handleMouseUp() {
        isDragging = false;
        canvas.style.cursor = "grab";
      }

      // Wheel control
      function handleWheel(e) {
        e.preventDefault();
        targetPosition += e.deltaY * 0.0005;
        updateJourneyProgress();
      }

      // Keyboard controls
      function handleKeyDown(e) {
        switch (e.key) {
          case "ArrowLeft":
          case "ArrowUp":
            targetPosition -= 0.02;
            updateJourneyProgress();
            break;
          case "ArrowRight":
          case "ArrowDown":
            targetPosition += 0.02;
            updateJourneyProgress();
            break;
          case " ":
            e.preventDefault();
            showWishCard();
            break;
          case "q":
          case "Q":
            showQuoteCard();
            break;
          case "f":
          case "F":
            toggleFullscreen();
            break;
          case "r":
          case "R":
            rebootSystem();
            break;
        }
      }

      // Update camera position with smooth interpolation
      function updateCameraPosition() {
        if (!routePath) return;

        // Smooth path following
        pathPosition += (targetPosition - pathPosition) * 0.08;

        // Handle wrapping
        while (pathPosition < 0) pathPosition += 1;
        while (pathPosition > 1) pathPosition -= 1;

        const position = routePath.getPointAt(pathPosition);
        const lookAhead = routePath.getPointAt((pathPosition + 0.03) % 1);

        camera.position.copy(position);
        camera.position.y += CONFIG.visual.cameraHeight;
        camera.lookAt(lookAhead);

        checkNearbyCheckpoints();
      }

      // Enhanced checkpoint detection
      function checkNearbyCheckpoints() {
        const threshold = 0.08;

        checkpoints.forEach((checkpoint, index) => {
          const distance = Math.abs(checkpoint.position - pathPosition);
          const wrappedDistance = Math.min(distance, 1 - distance);

          if (wrappedDistance < threshold && !checkpoint.shown) {
            showCheckpointImage(checkpoint, index);
            checkpoint.shown = true;

            // Haptic feedback
            if (navigator.vibrate) {
              navigator.vibrate([100, 50, 100]);
            }
          } else if (wrappedDistance >= threshold && checkpoint.shown) {
            hideCheckpointImage();
            checkpoint.shown = false;
          }
        });
      }

      // Enhanced checkpoint image display
      function showCheckpointImage(checkpoint, index) {
        const container = document.getElementById("checkpoint-container");
        const img = document.getElementById("checkpoint-image");
        const quote = document.getElementById("checkpoint-quote");

        img.src = checkpoint.imageUrl;
        img.onload = () => {
          container.classList.add("show");
        };

        quote.textContent =
          quotesShuffled[currentQuoteIndex % quotesShuffled.length];

        currentQuoteIndex++;
        if (currentQuoteIndex >= quotesShuffled.length) {
          quotesShuffled = shuffleArray(CONFIG.quotes);
          currentQuoteIndex = 0;
        }
      }

      function hideCheckpointImage() {
        document
          .getElementById("checkpoint-container")
          .classList.remove("show");
      }

      // Update journey progress bar
      function updateJourneyProgress() {
        const progressBar = document.getElementById("journey-fill");
        const progress = (pathPosition * 100) % 100;
        progressBar.style.width = progress + "%";
      }

      // Enhanced popup cards
      function showWishCard() {
        const card = document.getElementById("wish-card");
        card.classList.add("show");

        // Auto-hide after 5 seconds
        setTimeout(() => {
          card.classList.remove("show");
        }, 5000);

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(200);
        }
      }

      function showQuoteCard() {
        const card = document.getElementById("quote-card");
        const quote = document.getElementById("random-quote");

        quote.textContent =
          CONFIG.quotes[Math.floor(Math.random() * CONFIG.quotes.length)];
        card.classList.add("show");

        setTimeout(() => {
          card.classList.remove("show");
        }, 4000);

        if (navigator.vibrate) {
          navigator.vibrate(150);
        }
      }

      // System controls
      function rebootSystem() {
        // Show loading
        showLoadingSpinner();

        // Reset state
        pathPosition = 0;
        targetPosition = 0;
        currentQuoteIndex = 0;
        quotesShuffled = shuffleArray(CONFIG.quotes);

        // Hide UI elements
        document.getElementById("wish-card").classList.remove("show");
        document.getElementById("quote-card").classList.remove("show");
        hideCheckpointImage();

        // Reset terminal
        setTimeout(() => {
          hideLoadingSpinner();
          document.getElementById("terminal-overlay").style.display = "flex";
          document
            .getElementById("terminal-overlay")
            .classList.remove("hidden");
          document.getElementById("terminal-lines").innerHTML = "";
          document.getElementById("progress-fill").style.width = "0%";
          document.getElementById("boot-complete").style.display = "none";

          startBootSequence();
        }, 500);
      }

      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch((err) => {
            console.log("Fullscreen not supported");
          });
        } else {
          document.exitFullscreen();
        }
      }

      function toggleMusic() {
        const btn = document.getElementById("music-btn");
        btn.style.color =
          btn.style.color === "rgb(255, 255, 255)" ? "#00ffff" : "white";

        // Placeholder for actual music implementation
        if (navigator.vibrate) {
          navigator.vibrate(100);
        }
      }

      // Utility functions
      function showLoadingSpinner() {
        document.getElementById("loading-spinner").style.display = "block";
      }

      function hideLoadingSpinner() {
        document.getElementById("loading-spinner").style.display = "none";
      }

      function handleResize() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      // Enhanced animation loop
      function startAnimationLoop() {
        function animate() {
          requestAnimationFrame(animate);

          if (isInitialized) {
            updateCameraPosition();
            renderer.render(scene, camera);
          }
        }
        animate();
      }

      // Initialize on load
      window.addEventListener("load", () => {
        // Prevent default touch behaviors
        document.addEventListener("touchmove", (e) => e.preventDefault(), {
          passive: false,
        });
        document.addEventListener("touchstart", (e) => e.preventDefault(), {
          passive: false,
        });

        startBootSequence();
      });

      // Handle visibility changes for performance
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          // Pause animations when tab is hidden
        } else {
          // Resume animations when tab is visible
        }
      });
    </script>
  </body>
</html>
