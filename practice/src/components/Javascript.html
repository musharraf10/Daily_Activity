<!-- <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Javascript</title>
  </head>
  <body>
    <h1>Welcome Boss</h1>

    <table border="1" cellpadding="8" cellspacing="0">
      <thead>
        <tr>
          <th>User id</th>
          <th>Id</th>
          <th>Title</th>
          <th>Completed</th>
        </tr>
      </thead>
      <tbody id="table-body"></tbody>
    </table>

    <script>
      const tableBody = document.getElementById("table-body");

      (async () => {
        try {
          const res = await fetch(
            "https://jsonplaceholder.typicode.com/todos/"
          );
          const todo = await res.json();

          console.log("data is todo", todo);

          // ✅ Wrap single object in array so we can use forEach
          todo.forEach((t) => {
            const row = document.createElement("tr");

            const userIdCell = document.createElement("td");
            userIdCell.textContent = t.userId;
            row.appendChild(userIdCell);

            const idCell = document.createElement("td");
            idCell.textContent = t.id;
            row.appendChild(idCell);

            const titleCell = document.createElement("td");
            titleCell.textContent = t.title;
            row.appendChild(titleCell);

            const completedCell = document.createElement("td");
            completedCell.textContent = t.completed ? "Completed" : "Not yet";
            row.appendChild(completedCell);

            tableBody.appendChild(row);
          });
        } catch (err) {
          console.log("Error", err.message);
        }
      })();
    </script>
  </body>
</html>

<!-- 
Fake Data Fetching with Promises
Here's an example of a function that fakes fetching data using setTimeout and handles success/error with Promises:


function fetchDataWithPromises() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const randomNumber = Math.random();
      if (randomNumber < 0.5) {
        resolve({ message: "Data fetched successfully!" });
      } else {
        reject({ message: "Error fetching data!" });
      }
    }, 2000);
  });
}

// Usage
fetchDataWithPromises()
  .then((data) => console.log("Success:", data))
  .catch((error) => console.error("Error:", error));


Refactored with Async/Await
Here's the same function refactored to use async/await:


async function fetchDataWithAsyncAwait() {
  try {
    const data = await new Promise((resolve, reject) => {
      setTimeout(() => {
        const randomNumber = Math.random();
        if (randomNumber < 0.5) {
          resolve({ message: "Data fetched successfully!" });
        } else {
          reject({ message: "Error fetching data!" });
        }
      }, 2000);
    });
    console.log("Success:", data);
  } catch (error) {
    console.error("Error:", error);
  }
}

// Usage
fetchDataWithAsyncAwait();


Free APIs
Here are some free APIs you can use for testing:

1. JSONPlaceholder: https://jsonplaceholder.typicode.com/
2. Random User API: https://randomuser.me/
3. OpenWeatherMap API: https://openweathermap.org/api (requires API key)
4. GitHub API: https://api.github.com/
5. PokeAPI: https://pokeapi.co/

Promise Callback Async Await Example
Here's an example that demonstrates the difference between Promise callbacks and async/await:


// Promise callback
function fetchDataWithPromiseCallback() {
  fetch('https://jsonplaceholder.typicode.com/todos/1')
    .then(response => response.json())
    .then(data => console.log("Success:", data))
    .catch(error => console.error("Error:", error));
}

// Async/await
async function fetchDataWithAsyncAwait() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
    const data = await response.json();
    console.log("Success:", data);
  } catch (error) {
    console.error("Error:", error);
  }
}

// Usage
fetchDataWithPromiseCallback();
fetchDataWithAsyncAwait();


In this example, both functions fetch data from the JSONPlaceholder API and log the result to the console. The first function uses Promise callbacks, while the second function uses async/await. -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function callBack(success, failure) {
        console.log("Fetching data...");

        const validation = Math.random() > 0.3;
        console.log(validation);

        if (validation) {
          success({ data: "Data feteched successfully" });
        } else {
          failure({ data: "Failed to fetch data" });
        }
      }

      callBack(
        (s) => console.log(s.data),
        (f) => console.log(f.data)
      );
    </script>

    <script>
      function promiseFunc() {
        console.log("Function Promise Fetching Data");

        return new Promise((resolve, reject) => {
          setTimeout(() => {
            const isSuccess = Math.random() > 0.3;

            if (isSuccess) {
              resolve("Data fetched successfully");
            } else {
              reject("Failed to fetched data");
            }
          }, 2000);
        });
      }

      promiseFunc()
        .then((res) => console.log(res))
        .catch((err) => console.log("Error is ", err));

      async function getData() {
        try {
          console.log("Fetching data...");
          const result = await promiseFunc(); // waits here
          console.log("Success:", result);
        } catch (error) {
          console.error("Failure:", error);
        }
      }
      getData();
    </script>
  </body>
</html>
